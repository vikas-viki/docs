### let and const

`let` and `const` are also hoisted in javascript (initialised undefined in memory allocation phase), but they are stored in `Temporal dead zone`, rather than the main `Global execution context`.

`Temporal dead zone, is the time from hoisting of variable till it gets a value assigned(initialised). The temporal dead zone (TDZ) is not a separate memory space, it’s just the period between the start of the scope and the point of initialization, during which accessing the variable throws a ReferenceError.`. Variables inside them can only be accessed, once they are initialised with some value.


```js
console.log('asdf');
let a = 10;

let a = 20;
```

So the console.log won’t run because the engine throws a SyntaxError when parsing. `you can do the same (re declaration) of var variables, but not let variables. not even re declaration of let as a var variable. same goes for const, but its even stricter that, you can't leave it without initialization.`


you'll get a `TypeError` when you try to re assign a `const` type variable.
`Parsing means the JS engine reads your code and checks its structure. Then the engine breaks the code into tokens (small pieces like keywords, variables, operators) and then builds a syntax tree (AST – Abstract Syntax Tree).`

### Block scope.
a block is compound statement (combination of multiple statements). we create a block of statements, so that js can use it whereever it expects only one statement (ex: functions, if (expects only one statement after, so we use {} to block them up)).

```js
{
    console.log("asdf");
}
```
this is a valid js code, we're just blocking up the statements into one using `{}`.

```js
{
    var a = 10;
    let b = 20;
    const c = 30;
}
console.log(a); // 10
console.log(b); // reference error
```

`ReferenceError` cause, `let & const` are block scoped, meaning, they can't be accessed out the block they are declared. But `var` is function-scoped, meaning if you declare it inside a function, and try to access it later outside, it'll not be there, you'll get a `ReferenceError`, cause function has its own `execution context`, when it sees a variable, it allocates the memory to it, in its `EC` only, it'll not modify the global value.

```js
var b =1;
function a(){
    var b = 10;
}
a();
console.log(b); // 1 (b inside a() had its own EC) 
```

```js
var b =1;
let a = 10;
{
    var b = 10;
    let a = 20;
}
console.log(b); // 10 
console.log(a); // 10 cause the inner `a` had block scope, its available inside that block only.
// the outer a, is in TDZ(Temporal Dead Zone)
```

we can't do this
```js
let a = 100;
{
    var a = 20;
}
```
in this case, it tries to move a to global scope, but it sees that, a's already there, hence `SyntaxError`.

**`only function and GEC has seperate Execution Context, not block. Blocks just have lexical environemnt for themselves.`**