### this

the shortest javascript program that you can normally write is `empty file`.

If you write an empty file, the JS engine still creates a Global Execution Context (GEC).

The GEC always has:
Global object (depends on host: window in browser, global in Node, globalThis everywhere ES2020+). The host environment (browser, Node.js, etc.) injects those objects/functions before your code runs.

`every/any global object/function/variable that there exists before any execution is not by js at all, its provided by the host environemnt, either browser or any other.`

so whats actually happening, they are running their code first and then they ran our code, so that we access the js object, that we can access the global objects.

core APIs like setTimeout, console, document, I/O stuff are always native code, not written in JS.

The host does not write these in JS. They’re mostly C++ (or Rust, etc.) code.

The host just registers them into the JS global object before your code runs, so you can use them as if they were normal JS functions.

we can add our own functions (written in c++ or others) too.

```
Before globalThis, every host had its own way:

Browser → window or self

Node.js → global

Web Workers → self

Deno → globalThis

Now, the spec says:

There must exist a built-in global variable globalThis that references the global object, regardless of the host.

so js, never/ever creates anything for users (no builtin functions, variables, objects, ect..)
```

`this` is a JavaScript keyword. In the global scope, it points to the global object, which is created and provided by the host environment.


`At the top level, variables declared with var and function declarations are attached to the global object (in the global context). But let and const are not (they are kept in seperate scope, so that they can used to name the varibles, that are present in the global object, but dont override them like 'var').`


**`imp`**
`undefined meanse, there's something in gec related to it, not defined otherwise`