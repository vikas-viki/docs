## ✅ Debouncing

Debouncing ensures that a function runs only after it hasn’t been called again for a specified time.

If the event is triggered again before the delay finishes, the timer resets.

Useful for scenarios where you only care about the final action after a burst of events.

Example:
`User types in a search bar → API call is triggered only after the user stops typing for, say, 500ms.`

```js
function debounce(fn, delay) {
  let timeout;
  return function (...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn.apply(this, args), delay);
  };
}

const handleSearch = debounce((query) => {
  console.log("Searching for:", query);
}, 500);

document.getElementById("search").addEventListener("input", e => {
  handleSearch(e.target.value);
});
```

## ✅ Throttling

Throttling ensures that a function is executed at most once in a specified time interval, no matter how many times the event occurs.

It ignores extra calls until the interval has passed.

Useful for scenarios where you want to limit execution frequency.

Example:
`User keeps clicking a button → the handler executes once every 1 second max, even if 20 clicks happened.`

```js
function throttle(fn, interval) {
  let lastTime = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastTime >= interval) {
      lastTime = now;
      fn.apply(this, args);
    }
  };
}

const handleClick = throttle(() => {
  console.log("Button clicked!");
}, 1000);

document.getElementById("btn").addEventListener("click", handleClick);
```