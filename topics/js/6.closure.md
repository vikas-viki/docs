### closures

`closure is function along with its lexical environment, forms a closure.`


when this code is executed, it checks if `a` is present in the currext Execution Context, if not, move up (till GEC), it finds in the parent and logs it.

```js
function x(){
    var a = 7;
    function y(){
        console.log(a);
    }
    return y;
}
var z = x();
// many lines of code
z(); // outputs 7.
```

`although the whole function x is executed and removed out call stack and execution context is destroyed, how's it still able to print 7`.

```
Functions in JS carry their lexical scope with them when returned or passed around.

So y remembers the environment in which it was created (the scope of x), even after x’s execution context is destroyed.

This preserved scope is called a closure.

no matter how deeply nested a function is, if you return it (or pass it around), it carries its entire lexical scope with it.
```

```js
function outer() {
    let x = 10;

    function middle() {
        let y = 20;

        function inner() {
            console.log(x, y);
        }

        return inner;
    }

    return middle();
}

const fn = outer(); 
fn(); // 10 20
```

```
A returned function remembers its entire lexical environment chain, no matter how deep it was nested.

The closure keeps all parent scopes alive as long as they are needed.

so when you return a function, whole closure of that function was returned.
```


### QN

```js
function x(){
    var i = 1;

    setTimeout(()=>{
        console.log(i);
    }, 3000);
    console.log("Hello");
}
x();
```

prints `Hello` first and then `1` after 3 seconds.

```
Execution steps:

JS engine executes line by line.

Encounters setTimeout.

It offloads tasks to the host to perform the action.

JS engine does not wait — it continues.

Prints "Hello".

After 3 seconds, the browser’s timer finishes → callback (()=>console.log(i)) is moved into the Callback Queue.

The Event Loop checks:

Is the call stack empty? ✅ yes

Then it pushes the callback into the stack.

Callback executes → prints 1.
```

### QN 2

```js
let i = 1;
setInterval(()=>{
    console.log(i++);
}, i*1000);
// this won't print i, like you expect to be, the value of i in argument is evaluated only once.


// but this will work
let i = 1;
function run() {
    console.log(i++);
    setTimeout(run, i * 1000);
}
run();
```


```js
for(var i =0; i <= 5;i++){
    setTimeout(()=> {
        console.log(i);
    }, i * 1000);
}
// this will print 6, 5 times, cause by the time setTimeout ends, the value of i will be 6 (from it's lexical chain).
for(let i =0; i <= 5;i++){
    setTimeout(()=> {
        console.log(i);
    }, i* 1000);
}
// in this case, we made it let, so it'll work fine, cause let is block scoped, each time loop executes, its a new block.
// but its not true usage of closures, so we do like this.
for(var i =0; i <= 5;i++){
    function x(a){
        setTimeout(()=> {
            console.log(a);
        }, a * 1000);
    }
    x(i);
}
// now this uses closures to print the value of i incrementally.
```

`✅ Advantages of Closures`

Data Privacy & Encapsulation → variables stay hidden and can’t be accessed directly from outside.

State Preservation → a function can “remember” values even after its outer function has finished.

Functional Programming Power → enables things like function factories, currying, memoization.

`❌ Disadvantages of Closures`

Memory Consumption → variables stay in memory longer (can lead to leaks if not managed).

Harder Debugging → scope chains make it tricky to trace variables.

Overuse Complexity → excessive closures reduce code readability and maintainability.